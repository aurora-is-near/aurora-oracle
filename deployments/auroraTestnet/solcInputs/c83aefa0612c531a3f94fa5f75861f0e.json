{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n}\n"
    },
    "contracts/AuroraOracle.sol": {
      "content": "// SPDX-License-Identifier: CC-BY-1.0\npragma solidity 0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\n\n/**\n * Aurora oracle Stores external price data\n */\ncontract AuroraOracle is Ownable {\n    mapping(bytes32 => PythStructs.Price) public priceMap;\n    bytes32[] public usdStableTokens;\n    uint priceValidTimeRange;\n\n    constructor(\n        address initialOwner,\n        uint _priceValidTimeRange\n    ) Ownable(initialOwner) {\n        priceValidTimeRange = _priceValidTimeRange;\n    }\n\n    function updatePrices(bytes32[] memory tokenIds, int64[] memory prices, int32[] memory expos, uint updateTime) public onlyOwner {\n        require(tokenIds.length == prices.length && prices.length == expos.length, \"Array lengths do not match\");\n\n        for (uint i = 0; i < tokenIds.length; i++) {\n            PythStructs.Price memory newPrice = PythStructs.Price({\n                price: prices[i],\n                conf: 0,\n                expo: expos[i],\n                publishTime: updateTime\n            });\n            priceMap[tokenIds[i]] = newPrice;\n        }\n    }\n    \n    //function addUsdStableTokens add a list of USD stable tokens to the usdStableTokens array   \n    function addUsdStableTokens(string[] memory tokens) public onlyOwner {\n        for (uint i = 0; i < tokens.length; i++) {\n            usdStableTokens.push(keccak256(abi.encodePacked(tokens[i])));\n        }\n    }\n    \n    //function removeUsdStableTokens remove a list of USD stable tokens from the usdStableTokens array\n    //The function loops through the tokens array and for each token, it loops through the usdStableTokens array to find the token to remove    \n    //the token is stored as a keccak256 hash in the usdStableTokens array\n    function removeUsdStableTokens(string[] memory tokens) public onlyOwner {\n        for (uint i = 0; i < tokens.length; i++) {\n            for (uint j = 0; j < usdStableTokens.length; j++) {\n                    if (usdStableTokens[j] == keccak256(abi.encodePacked(tokens[i]))) {\n                    usdStableTokens[j] = usdStableTokens[usdStableTokens.length - 1];\n                    usdStableTokens.pop();\n                    break;\n                }\n            }\n        }\n    }       \n    \n    //function isUsdStableToken checks if a token is a USD stable token\n    //The function loops through the usdStableTokens array and checks if the token is in the array  \n    function isUsdStableToken(string memory token) public view returns (bool) {\n        bytes32 tokenHash = keccak256(abi.encodePacked(token));\n        for (uint i = 0; i < usdStableTokens.length; i++) {\n            if (usdStableTokens[i] == tokenHash) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //function readPairRate reads the price of a pair of tokens\n    //The function takes the tokenA and tokenB as strings and the decimals of the tokens as input\n    //The function calculates the tokenId by hashing the tokenA and tokenB\n    //The function checks if TokenA is a USD stable token and if it is, it reverts\n    //The function checks if TokenB is a USD stable token and if it is, it calls the readPriceUnSafe function with TokenA as tokenId and the targetPriceDecimals of TokenB\n    //If TokenB is not a USD stable token, then function getPairRate is called \n    function getPairRate(string memory tokenA, string memory tokenB, uint8 decimalsTokenB) public view returns (uint256) {\n        if (isUsdStableToken(tokenA)) {\n            revert(\"NA:TokenA StableToken\");\n        }\n        if (isUsdStableToken(tokenB)) {\n            return readTokenPrice(keccak256(abi.encodePacked(tokenA)), decimalsTokenB);\n        }\n        return getNonUSDPairRate(keccak256(abi.encodePacked(tokenA)), keccak256(abi.encodePacked(tokenB)), decimalsTokenB);\n    }\n\n    function readTokenPrice(bytes32 tokenId, uint8 targetPriceDecimals) internal view returns (uint256) {\n        PythStructs.Price memory price = priceMap[tokenId];\n        isPriceValid(price.publishTime);\n        return convertPriceToUint(price, targetPriceDecimals);\n    }\n\n    // Set the price valid time range\n    function setPriceValidTimeRange(uint _priceValidTimeRange) public onlyOwner {\n        require(_priceValidTimeRange > 0, \"Invalid priceValidTimeRange\");\n        priceValidTimeRange = _priceValidTimeRange;\n    }\n\n    function isPriceValid(uint publishTime) internal view {\n        require(block.timestamp <= publishTime + priceValidTimeRange, \"Price is outdated\");\n    }\n\n    // function getPairRate input are bytes32 of TokenA and TokenB and targetPriceDecimalsB\n    // The function returns the rate of tokenA to tokenB\n    // the function calculate the price by reading PythStructs.Price.price and PythStructs.Price.expo of Token A and Token B\n    // The function returns the price of TokenA to TokenB with multiply with targetPriceDecimalsB\n    function getNonUSDPairRate(bytes32 tokenA, bytes32 tokenB, uint8 targetPriceDecimalsB) internal view returns (uint256) {\n        PythStructs.Price memory priceA = priceMap[tokenA];\n        PythStructs.Price memory priceB = priceMap[tokenB];\n        isPriceValid(priceA.publishTime);\n        isPriceValid(priceB.publishTime);\n        return (convertPriceToUint(priceA, 9) * 10**targetPriceDecimalsB) / convertPriceToUint(priceB, 9);\n    }\n    \n    function convertPriceToUint(\n        PythStructs.Price memory price,\n        uint8 targetDecimals\n    ) private pure returns (uint256) {\n        if (price.price < 0 || price.expo > 0 || price.expo < -255) {\n            revert(\"Invalid price\");\n        }\n\n        uint8 priceDecimals = uint8(uint32(-1 * price.expo));\n\n        if (targetDecimals >= priceDecimals) {\n            return\n                uint(uint64(price.price)) *\n                10 ** uint32(targetDecimals - priceDecimals);\n        } else {\n            return\n                uint(uint64(price.price)) /\n                10 ** uint32(priceDecimals - targetDecimals);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}